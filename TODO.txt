Principles

In order for the project to succeed it must:
    * Require as little code as possible to create Test Mocks and Spies, so that mocking does not get in the way of testing.
    * Use natural language to express the configuration so tests are as clear as possible to read.
    * Have an auto-complete considered class structure, so that IDEs give you as much guidence as possible when tests are being written.
    * Issue assertion failures that are as clear as possible, so the meaning of the failure is easy to understand.

Implement

    Rename 'master'

    Spy
        Lots of checking on what you can call, when
        Split out the spy methods, to make it easier with auto-complete
        Defer the calculations of which call number to return, so there's more flexibility in the order?

        REALLY split the CallChecker class down, so you end up with perfect auto-complete

        implement - was called x times

    Think about 'allowAnyCall'
        Default to 'true' - so spy is easy to set up
        If expects is set, then set back to false
            UNLESS 'allowAnyCall' is called explicitly
        Then remove a lot of setup code from TestMockTest that is no longer needed

    Think about 'withAnyParameter' a bit more
        Need some error conditions, in case you try to set up something invalid

    Think about 'only checking a single parameter'
        withParameterAtPosition

    Type checking prior to checking equality - otherwise you get an indecipherable error

    No need to set 'withAnyParameter' - just imply it from the absence of parameters

    handledBy
        Can use standard Stub interface
        Can use a simplified Stub interface

    Need to be able to test:

        TestMock templateGenerator = new TestMock( TemplateGenerator.class );

        templateGenerator
            .expects()
            .method( 'generate' )
            .withParameter( 'Opportunity' )
            .andParameter( 'Opportunity_Products_Offered' )
            .andParameter( new Set<Id>{ opportunityLineItemList[0].OpportunityId } ) // only, this isn't set yet
            .returning( new Map<Id,String>{ opportunityLineItemList[0].OpportunityId => 'The generated Template' } ); // and here too

        Maybe:

        templateGenerator
            .expects()
            .method( 'generate' )
            .withParameter( 'Opportunity' )
            .andParameter( 'Opportunity_Products_Offered' )
            .andAnyParameter()
            .handledBy( new TemplateGeneratorMockHandler() );

    
        System.assertEquals( templateGenerator.called( 'generate' ).number( 1 ).parameter( 3 ).was() )

        That's why we need a spy, and a 'handled by'

        assertContains

Test:
    The behaviours work with Sobjects
    The behaviours work with Object instantiations

Think:
    How to pass 'expects parameter' when we're passing sObjects?
