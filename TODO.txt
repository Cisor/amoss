Principles

In order for the project to succeed it must:
    * Require as little code as possible to create Test Mocks and Spies, so that mocking does not get in the way of testing.
    * Use natural language to express the configuration so tests are as clear as possible to read.
    * Have an auto-complete considered class structure, so that IDEs give you as much guidence as possible when tests are being written.
    * Issue assertion failures that are as clear as possible, so the meaning of the failure is easy to understand.

Implement

    General:

        Think about 'withAnyParameters' a bit more
            Need some error conditions, in case you try to set up something invalid.

        Implement means of stating that you don't care about a single parameter
        E.g.
            templateGenerator
                .expects()
                    .method( 'generate' )
                    .withParameter( 'One We Care About' )
                    .andAnyParameter()
                    .andThenParameter( 'Another One We Care About' )
                    .returning( 'Something' );

        Think about 'only checking a single parameter'
            withParameterAtPosition

            E.g.
                templateGenerator
                    .expects()
                        .method( 'generate' )
                        .withParameterAtPostion( 2, 'One We Care About' )
                        .returning( 'Something' );

        Documentation
        Developer Documentation

    Mock:

        Implement andThenAnyParameter
        
        Type checking prior to checking equality - otherwise you get an indecipherable error

        How to pass an 'expects parameter' when we're passing sObjects?

        Consider splitting the class down, to improve the auto-complete

        handledBy
            Can use standard Stub interface
            Can use a simplified Stub interface

    Mock - Test Recorder format

        Can you simply add the Test Recorder format into the framework - for flexibility

    Spy:
        Checking on what you can call, when
        Consider splitting the CallChecker class down, so you end up with perfect auto-complete

        Think about 'allowAnyCall'
            Default to 'true' - so spy is easy to set up
            If expects is set, then set back to false
                UNLESS 'allowAnyCall' is called explicitly
            Then remove a lot of setup code from TestMockTest that is no longer needed

    Current Limitations:

        Need to be able to test:

            TestMock templateGenerator = new TestMock( TemplateGenerator.class );

            templateGenerator
                .expects()
                .method( 'generate' )
                .withParameter( 'Opportunity' )
                .andThenParameter( 'Opportunity_Products_Offered' )
                .andThenParameter( new Set<Id>{ opportunityLineItemList[0].OpportunityId } ) // only, this isn't set yet
                .returning( new Map<Id,String>{ opportunityLineItemList[0].OpportunityId => 'The generated Template' } ); // and here too

            Maybe:

            templateGenerator
                .expects()
                .method( 'generate' )
                .withParameter( 'Opportunity' )
                .andThenParameter( 'Opportunity_Products_Offered' )
                .andAnyParameter()
                .handledBy( new TemplateGeneratorMockHandler() );

        
            System.assertEquals( templateGenerator.called( 'generate' ).number( 1 ).parameter( 3 ).was() )

            That's why we need a spy, and a 'handled by'

Test:
    The behaviours work with Sobjects
    The behaviours work with Object instantiations