Amoss - Apex Mocks, Spies and Stubs

Development Ideals

In order for the project to succeed it must:
    * Require as little code as possible to create Test Mocks and Spies, so that mocking does not get in the way of testing.
    * Use natural language to express the configuration so tests are as clear as possible to read.
    * Have an auto-complete considered class structure, so that IDEs give you as much guidence as possible when tests are being written.
    * Issue assertion failures that are as clear as possible, so the meaning of the failure is easy to understand.

Design Principles:

    * The consumer should not need to reference any class other than the instantiation of the mock in the first place.
        * This limits the amount of noise in the specification of a mock.  Class names (espcially namespaced ones) get in the way of the meaning of the code and so they should not be required.
    * Designing Methods:
        * Every method call should be expressive of what it does in plain english, particularly within the context of where it is used.
        * Methods should only have one parameter, which is described by the context provided in the method name, so that it is always clear what is being passed in.
        * Methods should be set up so they can be strung together to form sentences giving a full description of the work being done.
        * For example:
            * call( 1 ).of( 'theStubbedMethod' ).parameters()
            rather than:
            * getParameters( 'theStubbedMethod', 1 )

    * Designing Classes:
        * Classes should be defined with the primary focus of making it easier for a consumer to use the framework, as opposed to making it easier for the developer to build the framework.
        * Particularly, where the context of the phrasing changes, a new object should be returned that provides an interface that is appropriate for that part of the phrasing.
        * For example:
            * when and expects on TestMock both return a TestExpectation.
                * The TestExpectation defines the phrasing (essentially the interface) for defining the expectation, being
                    * method
                    * withParameter / withAnyParameters / withParameterAtPostion
                    * returning / returns / willReturn / throws / throwing
                * The following methods then define the end of that phrasing, and result in a TestMock being returned
                    * then
                    * also
        * However, the consumer should never be concerned with this, and should not need to directly reference any class other than when initially constructing a TestMock


Implement

    Test:
        Test using expectations
        Test the behaviour of 'when' matching
            include a method that isn't set up

        Test expects with List, Set, Map - test assertions with the same - is List<Object> an Object?
        Test returns List, Set, Map

        methodUnderMockWithNoReturn - when setup to return something
        methodUnderMock - when setup not to return anything

    General:

        What happens with methods that are not supposed to return something?
            Looks like it works, just need to write tests to prove it

        Rename:
            Repository - Amoss

            TestMock - Amoss_Instance
            TestExpectation - Amoss_Expectation
            TestExpectations - Amoss_Expectations
            TestAsserts - Amoss_Asserts

            TestMockTest - Amoss_InstanceTest

        Can we wrap some of the inner classes with public interfaces, so that the consumer only sees that layer.

        Should everything be moved into one class file with inner classes?
        Assertions should all be moved into handleMethodCall, so that everything else can be properly tested

        Move the assertions out into another class that is instantiated, so it can be mocked in tests

        Think about 'withAnyParameters' a bit more
            Need some error conditions, in case you try to set up something invalid.

        Implement means of stating that you don't care about a single parameter
        E.g.
            templateGenerator
                .expects()
                    .method( 'generate' )
                    .withParameter( 'One We Care About' )
                    .andAnyParameter()
                    .andThenParameter( 'Another One We Care About' )
                    .returning( 'Something' );

        Think about 'only checking a single parameter'
            withParameterAtPosition

            E.g.
                templateGenerator
                    .expects()
                        .method( 'generate' )
                        .withParameterAtPostion( 2, 'One We Care About' )
                        .returning( 'Something' );

        Documentation
        Developer Documentation

    Mock:

        Implement andThenAnyParameter
            look in tests for the following, without specifying a parameter:
                .also().when()
                    .method( 'assert' )        
            Change this so that false will stop the test

        Type checking prior to checking equality - otherwise you get an indecipherable error
            Looks like you would need to pass the type into the expectation
            Or try / catch the assertion and report that it was probably a type error

        How to pass an 'expects parameter' when we're passing sObjects?

        Consider splitting the class down, to improve the auto-complete

        handledBy
            Can use standard Stub interface
            Can use a simplified Stub interface

    Mock - Test Recorder format

        Can you simply add the Test Recorder format into the framework - for flexibility

    Spy:

        why not 
            mockThing.get().countOf( 'method' )

        Checking on what you can call, when
        Consider splitting the CallChecker class down, so you end up with perfect auto-complete

        Think about 'allowAnyCall'

            Default to 'true' - so spy is easy to set up

            allows
                switches off allowAnyCall
            when
                does not switch off allowAnyCall
            expects
                switches off allowAnyCall

            allowsAnyCall
                switches on allowAnyCall, and does not allow it to be switched off again

            Then remove a lot of setup code from TestMockTest that is no longer needed

    Assertions:
        Is greater than, etc

    Current Limitations:

        Need to be able to test:

            TestMock templateGenerator = new TestMock( TemplateGenerator.class );

            templateGenerator
                .expects()
                .method( 'generate' )
                .withParameter( 'Opportunity' )
                .andThenParameter( 'Opportunity_Products_Offered' )
                .andThenParameter( new Set<Id>{ opportunityLineItemList[0].OpportunityId } ) // only, this isn't set yet
                .returning( new Map<Id,String>{ opportunityLineItemList[0].OpportunityId => 'The generated Template' } ); // and here too

            Maybe:

            templateGenerator
                .expects()
                .method( 'generate' )
                .withParameter( 'Opportunity' )
                .andThenParameter( 'Opportunity_Products_Offered' )
                .andAnyParameter()
                .handledBy( new TemplateGeneratorMockHandler() );

        
            System.assertEquals( templateGenerator.called( 'generate' ).number( 1 ).parameter( 3 ).was() )

            That's why we need a spy, and a 'handled by'

Test:
    The behaviours work with Sobjects
    The behaviours work with Object instantiations




Example Tests:

    Brittle version using Mock behaviours

    Less brittle version, using Spy behaviours

    @isTest
    private static void expectsMethodReturning_whenTheMethodIsCalledMoreThanOnce_willFailTheTest() {
        
        TestMock mockAsserts = new TestMock( TestAsserts.class );
        TestAsserts mockAssertsProxy = (TestAsserts)mockAsserts.proxy();
        mockAsserts
            .allows()
                .method( 'assertEquals' )
            .also().when()
                .method( 'assert' )
                .throws( new TestException( 'False assertion would normally halt the test, so we will too' ) );

        TestMock classUnderMock = new TestMock( ClassUnderMock.class );
        classUnderMock.setTestAsserts( mockAssertsProxy );
        ClassUnderMock classUnderMockProxy = (ClassUnderMock)classUnderMock.proxy();

        classUnderMock
            .expects()
                .method( 'methodUnderMock' )
                .returning( 'TheReturn' );

        Test.startTest();
            classUnderMockProxy.methodUnderMock( 'this', 1 );

            try {
                classUnderMockProxy.methodUnderMock( 'this', 1 );
            } catch ( TestException e ) {}
        Test.stopTest();

        String expectedAssertion = 'ClassUnderMock.methodUnderMock was called more times than was expected';
        System.assertEquals( false            , mockAsserts.get().latestCallOf( 'assert' ).parameter( 0 ), 'expects.method.returning, when the method is not called more times than expected, will fail by calling assert with false' );
        System.assertEquals( expectedAssertion, mockAsserts.get().latestCallOf( 'assert' ).parameter( 1 ), 'expects.method.returning, when the method is not called more times than expected, will fail by calling assert with an assertion message that clearly describes the issue' );
    }
